using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using Chirp.CSVDB;
using Chirp.General;
using JetBrains.Annotations;
using Xunit;

// Makes sure the tests are not parallel, so that files are not used at the same time
// (this became a problem after creating the singleton)
[assembly: CollectionBehavior(DisableTestParallelization = true)] 
namespace Chirp.DBFacade.Tests;

[TestSubject(typeof(DBFacade<>))]
// We *want* to test against the interface, so this IDE warning is ignored.
[SuppressMessage("Performance", "CA1859:Use concrete types when possible for improved performance")]
public class DBFacadeTest : IDisposable {
    public DBFacadeTest() {
        // The file has to be embedded in the project settings, see Chirp.DBFacade.Tests.csproj.
        Environment.SetEnvironmentVariable(DBEnv.envCHIRPDBPATH, Guid.NewGuid().ToString("N") + ".db");
        Environment.SetEnvironmentVariable(DBEnv.envSCHEMA, "data/schema.sql");
        Environment.SetEnvironmentVariable(DBEnv.envDATA, "data/empty.sql");
        
        Console.SetOut(new StringWriter()); // Stop messages from printing to console.
    }
    
    /** Two purposes:
     <list type="number">
     <item>The implementation of IDataBaseRepository to be tested can be set
     and changed in this one place rather than all over the file.</item>
     <item>Ensures that the tests all target the <i>interface</i> and not a
     particular implementation thereof.</item>
     </list>*/
    private static IDataBaseRepository<Cheep> Implementation => 
        DBFacade<Cheep>.Instance;

    [Fact]
    public void CanGetInstance() {
        IDataBaseRepository<Cheep> database = Implementation;
        Assert.NotNull(database);
    }
    
    /** Asserts that you can have a space in the username, that storing a message
     * with a single apostrophe in it works, that you can have a name that doesn't exist
     * in the database yet, and that you can put single-quotes around your message.
     */
    [Theory]
    [InlineData("Wendell Ballan", "This should be fine!", long.MaxValue)]
    [InlineData("Wendell Ballan", "Am I the only one whose message wasn't computer-generated by some website?!", long.MaxValue)]
    [InlineData("adgrardgaed", "I have no user-name, and I must scream", long.MaxValue)]
    [InlineData("adgrardgaed", "'I have no user-name, and I must scream'", long.MaxValue)]
    public void Store(string author, string message, long timestamp) {
        IDataBaseRepository<Cheep> database = Implementation;
        IEnumerable<Cheep> recordsBefore = database.Read();
        Cheep[] before = recordsBefore as Cheep[] ?? recordsBefore.ToArray();
        var record = new Cheep(author, message, timestamp);
        database.Store(record);
        IEnumerable<Cheep> recordsAfter = database.Read();
        Cheep[] after = recordsAfter as Cheep[] ?? recordsAfter.ToArray();
        Assert.Equal(before.Length + 1, after.Length);
        
        var cheep = new Cheep(author, message, timestamp);
        Assert.Contains(cheep, after); // Not deterministic which is actually first.
    }

    /** Asserts that the usernames produced by HashUserName() are always 8 characters
     * regardless of input length. */
    [Fact]
    public void HashUserNameLength() {
        const int repetitions = 30;
        for (int i = 0; i < repetitions; i++) {
            string newString = Guid.NewGuid().ToString("N")[..(i + 1)];
            string hashed = DBFacade<Cheep>.HashUserName(newString);
            Assert.Equal(8, hashed.Length);
        }
    }

    /** Asserts that the usernames produced by HashUserName() are deterministic
     * based on their input; the same input should produce the same output. */
    [Fact]
    public void HashSameInputGivesSameOutput() {
        const int repetitions = 30;
        for (int i = 0; i < repetitions; i++) {
            string newString = Guid.NewGuid().ToString("N")[..(i + 1)];
            string hashed = DBFacade<Cheep>.HashUserName(newString);
            Assert.Equal(hashed, DBFacade<Cheep>.HashUserName(newString));
        }
    }

    /** Asserts that the usernames produced by HashUserName() do not always produce
     * the same result (within reason... they're only 8 characters after all);
     * different input should produce different output. */
    [Fact]
    public void HashDifferentInputGivesDifferentOutput() {
        const int repetitions = 30;
        string GUID = Guid.NewGuid().ToString("N");
        var seen = new List<string>(repetitions);
        for (int i = 1; i < repetitions - 1; i++) {
            string hashed = DBFacade<Cheep>.HashUserName(GUID[..(i + 1)]);
            Assert.DoesNotContain(hashed, seen);
            seen.Add(hashed);
        }
    }

    public void Dispose() {
        DBFacade<Cheep>.Reset();
    }
}