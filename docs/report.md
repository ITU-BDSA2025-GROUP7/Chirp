---
title: _Chirp!_ Project Report
subtitle: ITU BDSA 2025 Group 7
author:
- "Nikki Skarsholm Risager <nris@itu.dk>"
- "Louis Falk Knudsen <lofk@itu.dk>"
- "Hassan Hamoud Al Wakiel <halw@itu.dk>"
- "Kristoffer Mejborn Eliasson <krme@itu.dk>"
- "Mette My Gabelgaard <mmga@itu.dk>"
numbersections: true
---
# Introduction (Hassan)
This report documents the process and the product of group 7's work from the course Analysis, Design and Software Architecture in 2025 at the IT University of copenhagen. The final product named *Chirp!* can be found at the [GitHub repository](https://github.com/ITU-BDSA2025-GROUP7/Chirp). An azure hosted [Website](https://bdsagroup7chirprazor-buhcfwanakgyaabx.germanywestcentral-01.azurewebsites.net/) with the final product will also be available temporarily. Group 7 consists of 5 people who have all contributed to the final product and it's documentation:
- Nikki Skarsholm Risager <nris@itu.dk>
- Louis Falk Knudsen <lofk@itu.dk>
- Hassan Hamoud Al Wakiel <halw@itu.dk>
- Kristoffer Mejborn Eliasson <krme@itu.dk>
- Mette My Gabelgaard <mmga@itu.dk>

With Eduard Kamburjan as the course manager and Sven Matthias Peldszus as a teacher. The following sections documents the final product, and the decisions that were made.


# Design and Architecture of _Chirp!_

## Domain model

[//]: <> (Comment to test the new workflow action.)

The database for the project is an SQLite database that's using Entity Framework Core as an object-relational mapper,
allowing the creation of a domain model containing classes that can be used as tables within the database while also allowing the use of these classes in the code.

The domain model of Chirp! consists of a couple of different classes. The two main classes are `Author` and `Cheep`.

`Author` represents a user in the program. It contains all relevant information about the user such as *UserName*, *DisplayName*, *Email*, *PasswordHash*, and a list of all cheeps that the author wrote.
Much of the functionality is inherited from `IdentityUser` as part of ASP.NET Identity.
This allows the use of functionality from ASP.NET identity such as support for registration, login page, as well as offloading some of the security concerns to Dotnet.
An author can also follow another author. This is done using the `FollowRelation` class. It contains the *Follower*, the *Followed* and a unique id representing the FollowRelation, allowing for a many-to-many relation between authors.
The reason for creating a separate class was to maximize the normal form of the database.
The course *Introduction to database systems* taught that it was best to achieve this by spitting the functionality of authors following each other into a separate table.
In hindsight, it would have been just as valid to add a field `public List<Author> Follows` to `Author` as EF Core separates the list into a separate table behind the scenes.

`Cheep` represents a message from a user. It contains relevant information such as the author who wrote it, what time it was written, the text message itself and a unique Id.

Below is shown a UML diagram depicting the structure of the domain model. Note that only the relevant fields of `IdentityUser` are shown.
![](.\images\DomainModel.png)

## Architecture — In the small (Kris)
![OnionArchitecture.png](images/OnionArchitecture.png)
The application is constructed in concentric layers using the domain model as a center. Each layer
can has dependencies from layers below it, but not above it.
- **The Domain Layer:** This layer contains the classes described in the Domain model section. The layer also contains the `DTO` classes `AuthorDTO` and `CheepDTO` that our repositories and services use.
- **The Repository Layer:** This layer contains the interfaces and classes for our repositories. Rather than using one generic repository, `AuthorRepository` and its interface `IAuthorRepository` handles `Author`s, while `CheepRepository` handles `Cheep`s `ICheepRepository`. This layer also contains the class `ChirpDBContext` which inherits the ASP.NET Core class `IdentityDBContext`.
- **The Service Layer:** In the service layer there are classes and interfaces related to services. These follow the same structure as the one for repositories, with separate classes and interfaces for `Author` and `Cheep`.
- **The UI Layer:** This is the layer for all the cshtml code used for the frontend. This includes both code generated by ASP.NET Core, as well as our own code. This is also where the `Program.cs` class that launches the entire app is located. The class `EmailValidationAttribute` is located in this layer, it was necessary to alter some behaviors during email validation, if there had been a significant amount of these attributes they could probably have gotten their own folder `Chirp.Infrastructure`

The application uses Razor pages for the application, which lets us use .cshtml files for the frontend and the `PageModel` class to provide similar functionality to the Code-behind model in `System.Web.UI` to write C# code for the .cshtml pages. For user validation and authorization the ASP.NET Core Identity framework was used, the code for which can be found in the `Chirp.Web.Areas` folder. The Identity framework is used to implement the various functionality described later in the User activities section.

## Architecture of deployed application (Louis)
The application is deployed to an application server owned by the vendor Microsoft Azure
at https://bdsagroup7chirprazor-buhcfwanakgyaabx.germanywestcentral-01.azurewebsites.net/.

The following deployment diagram shows the most relevant (out of several hundred) artifacts which
are included as part of the composite `.net-app` artifact that is deployed to the application server.

![Deployment diagram](./images/deployment.png)

## User activities (Hassan)
In Chirp!, users can do many actions such as logging in, writing cheeps, following other users and much more.

The diagram below illustrates what the typical journey of an unauthorized user may look like, where the goal of the user is logging into the application. The initial node represents opening the application and the final node is logging in using the login page.

![Unauthorized-activity-diagram](./images/unauthorized-activity-diagram.png "A activity diagram for the unauthorized users of Chirp!")

Authorized users can do a lot more activities than unauthorized.
The diagram below illustrates what the typical journey of an authorized user may look like. The initial node represents logging into the account, and the final node is logging out which can also be done by delete the account.

![Authorized-activity-diagram](./images/Authorized-activity-diagram.png "A activity diagram for the authorized users of Chirp!")

## Sequence of functionality/calls trough _Chirp!_ (My)

The Chirp application contains a bunch of different calls, between various parts of the application.
The diagram below shows the calls made when an unauthorized user visits the page.

![img](./images/rootSequenceDiagram.png)
*Diagram ??. Sequence diagram of the calls made when the unauthorized user goes to the root.*

Starting when an unauthorized user goes to the root endpoint of the application. In this case the public timeline.

Whenever a user attempts to retrieve the public timeline page, they send a GET request to the public timeline which is handled on the ``PublicModel``.
The method ``GetCheeps()``is called on the ``CheepService``,
which calls the method of the same name on ``CheepRepository``. The repository fetches the cheeps from the database.
In the diagram that is denoted by SELECT cheeps, which is not the full SQL statement. The full statement takes  pagination and ordering into account for fetching cheeps.
On the diagram, the full statement was left out for simplicity.


The ``GetCheeps`` methods are all asynchronous and therefore return ``Task<List<CheepDTO>``. These can be converted into ``List<CheepDTO>`` using the ``await`` keyword. The list can then be used to render the UI.
In the end, the client resives an http response message with the code 200, meaning ok along with the html page.

# Process

## Build, test, release, and deployment

The processes of building, testing, releasing and deploying are relatively simple and always follow the same pattern making them simple to automate.
For this reason, there has been added a total of 3 GitHub actions to automate these processes. The actions are as follows: *BuildAndTest*, *Release*, and *Deploy*.
Each GitHub action has a trigger that activates the action. These differ from each action.

### Build And Test
The purpose of the *BuildAndTest* action is, as the name implies, to ensure that the project is always buildable and that each test passes.
The integration with GitHub makes this action highly useful as the action can be ran on a pull request,
and GitHub will point out any compiler waning as well as disallowing the pull request to be accepted if any tests fail.

The action is activated whenever a push or pull request is made.
After the action has successfully built the project, then it will download playwright.
This is because the *ubuntu-latest* machine that the action is ran from doesn't have playwright installed, and it's required for some of the tests.
It then runes the tests.
If there was a problem with any of the steps involved, then the action will fail and a potential pull request will be marked as not suitable for merging.

The action is illustrated in the UML activity diagram below.

![](./images/BuildAndTest.png)

### Release
The purpose of the *Release* action is to automate the process of making an GitHub release.

It's activated when a push is made with a tag that fits the regex expression `v[0-9]+.[0-9]+.[0-9]+`
It firsts runs what's equivalent to the *BuildAndTest* action, testing that all tests pass before proceeding.
Once this is done, the action can publish the program. It is published 3 times, once for Windows, Mac, and Linux.
The published program does not contain the database required to run the program. For this reason, the database is also copied to each of the published programs.
After this is done, alle 3 programs can be zipped and released

The action is illustrated in the UML activity diagram below.

![](./images/Release.png)

### Deploy
The purpose of the *Deploy* action is to deploy the program form GitHub onto Azure, making the program publicly assessable from the website.

The code for the action is based on the code provided by Azure when creating a new webapp.
It's activated whenever something is a pushed to main, insuring that the program that's live on azure is always up to date with the current state of the main branch.

The action is illustrated in the UML activity diagram below.

![](./images/Deploy.png)

## Team work (Nikki)
The teamwork in the group has been one of good communication.
Before the project work began, a meeting was held to discuss how the group work should be carried out.
Here it was agreed to hold 2 meeting each week. Both after a lecture where access to TA's was available.
It was also discussed whether each member would prefer working in groups or alone, along with expectations for working in the weekends and while on vacation.
An agreement was made that whenever someone was done with their issue, they would make a pull request.
The pull request would be reviewed by a member not associated with the creation of the pull request.
When handling a pull request, the reviewer should review based on code quality, the requirements for fixing the issue, along with sufficient testing.
It was agreed that if a feature was not sufficiently tested, then the feature was assumed to be non-functional and therefore could not be approved.
This resulted in higher test coverage and less faulty code.

The purpose of the meetings would be to discuss how much progress has been made since last meeting,
discuss and create new issues based on the lecture notes, delegate the issues to the group members, and discuss any potential collaboration between groupmates.
The work on the project would then be carried out in between meetings, allowing for flexible working hours.


Below is shown the GitHub project board shortly before handing in the report. It contains issues that are marked as either complete, in progress or to-do.

![](./images/ProjectBoard.png)

Most of the issues are done. The four issues that are left in to-do are all bug fixes or quality of life improvements. These are:
- A bug where the authentication cookie of a logged-in user is still alive in the browser even after deleting the user. This can be replicated by switching branches where the user does not exist in one of the branches. Thereby *'deleting'* the user by switching branches.
- A bug where registering a user with no `DisplayName` will cause an issue, because the `DisplayName` is equal to the `Username` when `DisplayName` is blank. `Username` and `DisplayName` does not have the same restraints, this can leave the user with an illegal `DisplayName`.
- There are no error message displayed to the user if, for some reason, a Cheep failed to be sent.
- An issue making it impossible to have multiple .cs files that contain PlaywrightTests.

It has been chosen not to complete the above issues, due to time constraints and that the issues do not massively affect the end user.

Below is a diagram showing the process from creation of an issue, to completing the issue. Starting from receiving a task from the lecturer or from finding a bug in the program:

![](./images/HandelingIssues.png)
If any step of the diagram proved difficult, like if a lecture note task was ambiguous or a feature was particularly hard to write tests for, help from TA's proved useful.

## How to make _Chirp!_ work locally (Louis)

### Setup
#### Dependencies

The application requires you to have installed [.NET 9.0](https://dotnet.microsoft.com/en-us/download)
or later.
Any other missing dependencies should be automatically installed when building/running the program.

#### User secrets
For the program to work at all, a "user secret" related to GitHub authentication must be set.\
Two values, a _client ID_ and a _client secret_, need to be obtained directly from
[GitHub](https://www.github.com) through their interface for [registering a new OAuth app](
https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authenticating-to-the-rest-api-with-an-oauth-app).\
When prompted, you can set the "Homepage URL" to `http://localhost:5273/`,
and the "Authorization call-back URL" to `http://localhost:5273/signin-github`.

Execute the following console commands (omitting the optional portion in brackets if
already standing in the `src/Chirp.Web` directory). Replace `<client ID>` and `<client secret>` with
the respective values.
```
dotnet user-secrets set "authenticationGitHubClientId" <client ID> [--project src/Chirp.Web]
```
```
dotnet user-secrets set "authenticationGitHubClientSecret" <client secret> [--project src/Chirp.Web]
```

If anything goes wrong, the user secret settings can be reset by executing the following commands in order:
```
dotnet user-secrets clear [--project src/Chirp.Web]
```

```
dotnet user-secrets init [--project src/Chirp.Web]
```

### Run
To build and start the program on an available port, execute the following command in a terminal
emulator while standing in the project root:

```
dotnet run --project src/Chirp.Web
```

or, if you have an implementation of Make installed,

```
make start
```

A message in the console will inform you of the specific URL to navigate to in your browser in
order to interact with the web application. Depending on your terminal emulator, you may be able to simply
click the link to do so directly.

## How to run test suite locally
To run the test suite, the program does *not* need to be running locally in the background. Running the test suite can be done in two ways, depending on if Make is installed on your local computer.
If it is installed, running this command from the root directory will start the test suite:
```
make test
```
Alternatively if Make is not installed, running the following command from the root directory will start the test suite:
```
dotnet test
```

The test suite consists of 111 tests. There are 3 types of tests in the suite:
1. Unit tests: Tests a singular function, class, or field.
2. Integration tests: Tests the interplay between classes and functions.
3. End-to-end tests: Tests the product as interacted with by the user. This is done though playwright

Here is a brief list of what is being tested

##### Author Repository
1. Creating authors
2. Following authors
3. Retrieving Authors
4. Deleting Authors
5. AuthorDTO works as expected
6. CheepDTO works as expected

##### Cheep Repository
1. Retrieving Cheeps
2. Retrieving pages of cheeps
3. Cheep timestamps are correct
4. Creating cheeps
5. Cheep content
6. Safe from SQL-injection
7. Retrieving cheeps from user that follows another, also retrieves the followed user

##### Playwright tests
1. User can log in
2. User can register
3. Navigation bar changes
4. Users can log out
5. Users can follow & unfollow
6. About me has following page
7. My page shows displayName
8. Cheeps are shown
9. Deleting users
10. Users can send cheeps
11. Sending cheeps are safe from XSS attacks
12. Users can Delete cheeps
13. About me page exists
14. Page arrows work
15. Users can search for users

# Ethics

## License (My)
To choose our license, we first looked at the dependencies of our project. And registered that we
are only using Microsoft libraries.

We chose the MIT license because it is simple and to the point. It is the one .Net uses. and we don’t
have anything else that shouldn't work with it, since no obscure libraries are used in this application.

The MIT license allows other people to use our code, and since we are not a business trying to earn money from the project.
There is no particular reason or fear that someone will copy the project and distribute it commercially,
Therefore, we have no need to gatekeep our code and want to take part in the sharing of code.

## LLMs, ChatGPT, CoPilot, and others (Kris)
We have used the free version of ChatGPT in a limited scope during development. To gather the groups
thoughts on the topic an informal interview was used to guide the conversation around important
topics about AI use and its role in the project. Most of the team have had some prior experience
when using AI. ChatGPT was in all but one case used in a way similar to google, for looking up
information on problems the team was facing. The output of ChatGPT was then used as a basis for what
to look into, statements made by the AI were compared to what other students and sources had to say
about the subject. In one case when writing a test, the output of ChatGPT was so evidently the
solution that we were confident copying the line of code produced was good. This came after writing
many tests without the use of ChatGPT.

Overall each team member of the group are skeptical that AI use is particularly helpful overall,
each member who have used AI have generally had a low amount of confidence that the details of the
AI was correct. Furthermore, even when correct on a specific topic, team members report that other
prompts relating to the same topic might not necessarily produce correct information. Team members
also did not find AI to be any more helpful than other sources of information, it at best served as
a compliment to lecture slides, text books, official documentation, online guides,
other students and TAs.

Finally, several of the team members reported dissatisfaction with dealing with AI. One reported
that it was less enjoyable than dealing with coding problems directly. Another member reported that
the existence of AI tools itself robbed them of some of the joy of programming, that you feel like
you're being inefficient if you don't use it, but that using it removes the creative problem-solving
aspect of programming.